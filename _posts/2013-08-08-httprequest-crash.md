---
layout: blog
title: Http网络请求回调野指针问题
category: tech
excerpt: 界面退出View被回收，导致请求回调出现野指针，针对这一问题的解决方案思考
---

最近在做一个iOS的网络层框架<a href="https://github.com/xuhengfei/iOS-Interactive" target="_blank">Interactive</a>

被问到如何解决网络请求的回调野指针问题。

之前没有考虑过这个问题，针对这个问题也想了很久。

先说说这个问题的来源吧：

我们在一个UIViewController里面会包含一些Http网络请求，请求返回时就能收到相应的数据，拿到这些数据就可以相应的绘制界面了。

我们的App需要支持iOS 4.3版本，但是在4.3版本里面是没有weak关键词的，只有unsafe_unretained 关键词

这两个关键词的区别是：

如果使用了weak，当对象被回收后，weak引用会自动设置为nil。objective-c有一个特性就是如果对象为nil，在此对象上调用任何方法，都不会导致异常。
因此即便对象被回收了，你再调用这个引用对象上的方法也不会导致异常crash。

而如果使用unsafe_unretained关键词时，对象被回收后，引用不会有变化，
在此后如果再调用这个引用对象上的方法，就会出现野指针访问，导致程序crash了。

现在的问题就是，在使用unsafe_unretained关键词时，如何保证http请求响应时不发生crash

***

####目前的解决方案

根据前人的经验，目前的SDK中的解决方案是，在发送请求时，业务调用方会在这个Request上设置一个delegate。
SDK利用<a href="https://github.com/mikeash/MAZeroingWeakRef" target="_blank">MAZeroingWeakRef</a>这个开源库来监听delegate的回收状态。
如果delegate被回收了，就取消对delegate的调用。

***

####我的解决思路

目前的<a href="" target="_blank">Interactive</a>框架采用的时，异步请求会返回一个Handler，通过持有这个Handler，我们可以对这个请求执行取消操作。
取消了这个请求，自然就不会有回调异常的问题了。

受现有SDK解决方案的影响，我也在考虑，Interactive框架中如何集成这个智能机制。自动帮助使用者来解决这个crash问题，让这个问题变成透明，使用者无需关注此问题呢？

这个问题我想了好几天，最终的结论是这样的：

***

####我的结论

现有SDK中通过对delegate来判断是否需要进行回调。这个方案能够解决大部分时候的问题，但是还是有漏网之鱼的。

比如一个Httq请求的delegate并没有被回收，但是delegate的回调代码中，仍然可能会使用已经被回收的引用对象，导致野指针crash。

回到根本性的问题上，对于网络层框架来说，框架无法准确的判断该请求是否需要取消。而是否需求取消的逻辑应该是由业务来解决的。

框架盲目的来承诺解决这个本不该属于自己的问题。会导致问题没有被从根本上解决，当出现特殊案例时就会出现bug。而这个bug的责任则归属框架了。

ASIHttpRequest库有一个方法：clearDelegatesAndCancel 

这个方法用来清理delegate并且取消这个请求。

ASI也没有去解决智能取消请求的问题，而仅仅是对外开放了这个方法，决策权交给了外部的业务方。
我想原因应该是和我的思路有相同之处：框架无法判断请求该何时被取消，既然没有能力判断，那就交给外部来主动触发。


鉴于上述的想法，我觉得Interactive框架也不做这个智能取消请求的功能，仍然是通过返回Handler的方式，让业务方来决定何时需要取消。

而实际工作中确实会碰到这个野指针的问题，那又如何解决呢？

我觉得业务方应该在Interactive框架的外围再做一个辅助的功能，比如在ViewController的dealloc方法里面自动对当前页面的所以Http请求进行取消动作。
类似这种方式来解决这个野指针的问题。但是这个功能一定不适合做在框架内部！

有了这个根本性的结论，回到文章最开头的weak和unsafe_unretained，
其实即便我们使用iOS5以上，我们用weak来替换 unsafe _unretained，
我们仍然不能解决根本性的问题，因为weak只能确保在nil上调用方法不抛异常，但是从逻辑上来说仍然是错误的。我们本不应该去回调这段代码，却仍然去调用了。

虽然没有导致crash，但是仍然会有潜在的风险：业务中一些不应该被执行的代码执行了，而我们无法评估这会带来的后果。

因此，即便我们可以用weak关键词了，这个weak关键词不能根本上解决我们的问题。

从严谨性的角度，我们仍然应该通过Handler来主动控制这个取消行为，而不是放任代码被不合理的调用！

